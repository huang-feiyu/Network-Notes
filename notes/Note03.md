# Chapter 3: 传输层

>传输层位于应用层和网络层之间，为不同主机上的应用程序提供通信服务。

[TOC]

### 传输层服务

为**不同**主机应用**进程**间的逻辑通信，运行于 **端系统**

* 两个可用协议
  * TCP：可靠有序的交付（面向连接的服务、拥塞控制、流控制）
  * UDP：无序的交付（IP 协议的扩展）

| 传输层             | 网络层             |
| ------------------ | ------------------ |
| 进程之间的逻辑通信 | 主机之间的逻辑通信 |
| 报文段 segment     | 数据报 datagram    |
| TCP, UDP           | IP                 |

### 多路复用 & 多路分解

* 接收端：分发 segments 给正确的 socket
* 发送端：从多个 sockets 汇集数据，使用 header 封装数据

分解原理：

* 每个数据报都有 source IP 和 destination IP => 标识主机
* 每个数据报携带一个传输层 segment，每个数据报都有 source port 和 destination port => 标识进程

无连接 UDP 的分解：

* 发送端：使用 dest IP 和 dest port 生成 sockets
* 接收端：UDP 仅仅使用 (dest IP, dest port)，不对 source IP 作任何处理

面向连接 TCP 的分解：

* socket 使用 4元组 区分，故一个主机可对应多个 server socket
* 接收端：TCP 使用 四元组 重定向至相应的 socket
  * Web server 为不同 client 准备不同的 socket

### 无连接的传输服务：UDP

UDP: User Datagram Protocol -- 对 IP 的简单扩展

* 多路复用、多路分解
* 差错检测（checksum，将数据段看作 16 bit 不断相加求反）
* 无连接：没有握手过程
* 应用：DNS，Skype，SNMP
* **不可信**传输，需要在应用层实施

### 可靠数据传输原理

> 不可信信道固有的特征决定了可信数据传输协议的复杂性

* 完美信道上的可信数据传输
  * 假设下层信道是完美信道
  * sender 发送，receiver 读取（各有自己的 FSM）
* 具有比特位错误的信道
  * 数据报在下层信道传输中可能发生比特位翻转错误
  * 增加：错误检测、接收者反馈（ACK），重传
    * sender：添加顺序号
    * receiver：检测是否接收到重复的 pkt，处理混淆的 ACK/NAKs（接收者使用上一次发送的 ACK 取代 NAK，标识数据报顺序号）
* 一个可能出错和丢包的信道
  * 下层信道可能丢失数据（data or ACKs）
  * 增加：等待 ACK 一段时间（timer）后重传
    * 允许发送多个 “在途”（等待确认）的数据报（窗口 Go-Back-N）
    * 选择重传，仅重传未确认的数据报（需要缓冲以保持 order）=> 难以确认不同数据报的顺序号范围和窗口大小

### 面向连接的传输：TCP

##### 概述

* 点对点：发送者 & 接收者
* 全双工：双向数据流动
* 面向连接：传输数据前，通过握手初始化状态
* 可靠、有序字节流：没有“消息边界”
* 流水线：窗口大小由 TCP 拥塞和流量控制决定
* 流控：发送者配合接收者调整发送速率
* 拥塞控制：发送者根据网络情况调整发送速率

##### 段结构

```
source pPort # | dest port #
sequence number
ACK number
head len| not used |U|A|P|R|S|F| Receive window
checksum | Urg data pointer
Options (variable length)
application data (variable length)
```

* U：urgent data（弃用）
* A：Ack # valid
* P：push data now（弃用）
* R, S, F：setup，teardown commands

---

顺序号字段：该报文段第一个字节在字节流中的编号

ACK 号字段：期望**从对方**收到的下一个报文段首字节序号（累计确认）

超时重传：大于 RTT（SampleRTT 多次测量的平均，重传忽略，最后使用加权平均与安全边际）

##### 可信数据传输

TCP 在不可靠的 IP 传输基础上建立可靠传输

* 管道化报文段
* **累计确认**
* 使用单个重传 timer
* 重传由以下事件触发：timeout events，duplicate acks

---

发送者事件：

* 从应用层接收数据
  * 封装为带 seq# 的段
  * 启动定时器
* 超时
  * 重传引起超时的报文段
  * 重启定时器
* 接到 Ack
  * 接收到新的确认，更新确认数据
  * 如果有未确认段，重启定时器

##### 流控

流量控制：速度匹配的服务；发送者通过控制发送速度，消除接收方缓冲区溢出的可能性

* 接收端告诉发送端，Rwnd 可用缓存空间
* 发送端通过限制确认数据，以与 Rwnd 相适应 => 保证接收缓冲区不会溢出

##### 连接管理

传输数据前，发送/接收方“握手”：

* 同意建立连接
* 同意连接参数

三次握手（协商序列号，保证同一个连接）：

1. C2S: SYNC 报文（请求连接）
2. S2C: SYNC/ACK 报文（表明服务器在线）
3. C2S: 回复 SYNCACK 报文（表明客户机在线）

四次挥手：

1. C2S: FIN 报文（停止发送数据，主动关闭TCP 连接）
2. S2C: FIN/ACK 报文，上层 App 关闭（TCP 中 C2S 连接释放）
3. S2C: FIN 报文（等到所有报文发完，才能发送 FIN 段）
4. C2S: FIN/ACK 报文

### 拥塞控制原理

太多的数据源发送太多的数据，并且发得太快，以至于无法处理 => 丢包（路由器缓冲区有限）、延迟（路由器排队）、不必要重传

* **端到端的拥塞控制**：拥塞由端系统从延迟和数据丢失**推断**
* 网络辅助的拥塞控制：路由器反馈网络拥塞信息到端系统

### TCP 拥塞控制

发送感知到拥塞，则限制发送数据（减小 ConWin）

* CongWin：拥塞窗口，动态函数
* 如何感知拥塞
  * 报文段丢失：超时或 3 个重复 acks
  * 3 个重复 ACKs：表示网络能够传输数据报
  * 超时：网络很拥塞

策略：加性增（每个 RTT 周期增加 ConWin 一个单位），乘性减（检测到报文段丢失，ConWin 减半）

慢启动：发送方以指数速度增加其发送率，直到一个报文段丢失事件发生

快速恢复：检测到丢失 ConWin 减半

